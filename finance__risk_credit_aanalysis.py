# -*- coding: utf-8 -*-
"""Finance _Risk_Credit_Aanalysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Cn0m80yI_1Zw0OtCzeHyYQ9vsC6cC_bF

# A. **Définition du problèmes :**
Le problème que nous cherchons à résoudre est de prédire l'approbation ou le rejet d'une demande de prêt par une institution financière, en se basant sur les informations fournies par le demandeur.

La variable cible dans notre jeu de données est la colonne Loan_Status, où 'Y' indique que le prêt a été approuvé et 'N' indique qu'il a été refusé.

L'objectif principal est de construire un modèle de classification qui puisse apprendre des relations entre les différentes caractéristiques des demandeurs de prêt (telles que le genre, le statut matrimonial, le revenu, le montant du prêt, l'historique de crédit, etc.) et la décision d'approbation du prêt.

En termes opérationnels, ce modèle vise à :

Prédire la probabilité qu'une nouvelle demande de prêt soit approuvée ou refusée.
Identifier les facteurs qui influencent le plus la décision d'approbation du prêt.
Potentiellement aider l'institution financière à standardiser et à optimiser son processus de décision d'octroi de crédit.
Il est important de noter que, bien que la variable cible actuelle soit "Approuvé" ou "Refusé", dans un contexte de risque de crédit plus large, nous pourrions ultérieurement vouloir transformer cela en une probabilité de "bon" ou "mauvais" payeur si nous avions des données de suivi sur le remboursement effectif des prêts. Cependant, pour l'instant, notre tâche se concentre sur la prédiction de la décision d'approbation initiale.

#B. **Importation des PACKAGES**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from ipywidgets import interact, HBox
import ipywidgets as widgets
import pickle as pkl
import warnings
warnings.filterwarnings("ignore")

# Définir le style des graphiques Seaborn pour une meilleure esthétique
sns.set_style("whitegrid")

"""# C - **Importation et lecture des données**"""

from google.colab import drive
drive.mount('/content/drive')

try:
    Data = pd.read_csv("/content/drive/MyDrive/Colab Notebooks/Risk_Credit_Aanalysis/Datas/train.csv")
    print('Les données sont chargées dans notre environnement de travail donc on va les lire directement')
    Data=pd.DataFrame(Data)
    Data.head(3)   # Affiche les premières lignes du DataFrame pour vérifier le chargement
except FileNotFoundError:
    print("Erreur: Le fichier 'train.csv' n'a pas été trouvé dans le chemin spécifié. Veuillez vérifier le chemin et le nom du fichier.")

Data=pd.DataFrame(Data)
Data.head(3)

"""# D - **Analyse exploratoire des données**

## 1- ***Compréhension Initiale des Données :***
"""

# Afficher les 5 premières lignes du DataFrame Data
print("Premières 5 lignes du DataFrame Data :")
Data.head(3)

print("\n")

# Afficher les 5 dernières lignes du DataFrame Data
print("Dernières 5 lignes du DataFrame Data :")
Data.tail(3)

"""- I**dentifiant Unique** : La colonne Loan_ID semble être un identifiant unique pour chaque demande de prêt. Elle ne devrait pas être directement utilisée pour la modélisation, mais elle est utile pour le suivi des enregistrements.
- **Types de Données Mixtes** : Nous voyons différents types de données, notamment des chaînes de caractères (pour les variables catégorielles comme Gender, Married, Education, Property_Area, Loan_Status), des nombres entiers (Dependents), et des nombres à virgule flottante (ApplicantIncome, CoapplicantIncome, LoanAmount, Loan_Amount_Term, Credit_History).
- **Valeurs Manquantes** : On remarque une valeur NaN dans la colonne LoanAmount dès la première ligne. Cela indique la présence de valeurs manquantes dans le jeu de données, que nous devrons traiter lors de l'étape de préparation des données.
- **Variable Cible** : La colonne Loan_Status est notre variable cible, avec des valeurs 'Y' (prêt approuvé) et 'N' (prêt refusé).
- Potentielle Catégorie Ordinale : La colonne Dependents contient des valeurs comme '0', '1', '2' et '3+'. Le '3+' pourrait indiquer une catégorie ordinale ('3 ou plus'). Nous devrons examiner la distribution de cette variable.
- **Binaire Catégoriel** : Credit_History semble être une variable binaire (0 ou 1), représentant probablement l'historique de crédit (présent/absent ou bon/mauvais).

"""

# Obtenir les informations générales du DataFrame Data
print("\nInformations générales du DataFrame Data :")
Data.info()

"""- Nombre d'Observations : Le DataFrame contient 614 entrées (lignes), indexées de 0 à 613.
Nombre de Colonnes : Il y a un total de 13 colonnes.
- Types de Données :
1.   int64: 1 colonne (ApplicantIncome).
2.   float64: 4 colonnes (CoapplicantIncome, LoanAmount, Loan_Amount_Term, Credit_History).
3.   object: 8 colonnes (Loan_ID, Gender, Married, Dependents, Education, Self_Employed, Property_Area, Loan_Status). Les colonnes de type object contiennent généralement des chaînes de caractères et représentent des variables catégorielles (ou potentiellement des données mixtes).
- **Valeurs Non Nulles et Valeurs Manquantes** : C'est une information cruciale. On observe que plusieurs colonnes ont moins de 614 valeurs non nulles, ce qui signifie qu'elles contiennent des valeurs manquantes :

1.   Gender: 601 valeurs non nulles (13 manquantes).
2.   Married: 611 valeurs non nulles (3 manquantes).
3.   Dependents: 599 valeurs non nulles (15 manquantes).
4.   Self_Employed: 582 valeurs non nulles (32 manquantes).
5.   LoanAmount: 592 valeurs non nulles (22 manquantes).
5.   Loan_Amount_Term: 600 valeurs non nulles (14 manquantes).
7.   Credit_History: 564 valeurs non nulles (50 manquantes).

- **Utilisation de la Mémoire **: Le DataFrame utilise environ 62.5 KB de mémoire.
La présence de valeurs manquantes dans plusieurs colonnes est une constatation importante. Nous devrons aborder cette question lors de l'étape de préparation des données
"""

# Examen des noms de colonnes si tout est Okay
print("\nNoms des colonnes du DataFrame Data :")
print(Data.columns)

"""Les noms des colonnes de votre DataFrame Data semblent être clairs, cohérents et significatifs. Ils décrivent bien les informations contenues dans chaque colonne."""

# Séparation des variables numériques et des variables catégorielles
var_num = ['ApplicantIncome', 'CoapplicantIncome', 'LoanAmount','Loan_Amount_Term','Credit_History']
var_cat = ['Loan_ID','Gender', 'Married', 'Dependents', 'Education', 'Self_Employed', 'Property_Area', 'Loan_Status']

var_num = pd.DataFrame(Data[var_num])
var_cat = pd.DataFrame(Data[var_cat])

"""**TYPES DE VARIABLES**
- **Numériques**:
1.   ***Continues*** : ApplicantIncome, CoapplicantIncome, LoanAmount.
2.   ***Discrètes*** : Loan_Amount_Term (bien qu'elle ait peu de valeurs uniques), Credit_History (peut aussi être vue comme catégorielle binaire).

- **Catégorielles**:
1.   ***Nominales*** : Loan_ID, Gender, Married, Education, Self_Employed, Property_Area.
Ordinales (Potentielles) : Dependents (avec la catégorie '3+').
2.   ***Cible*** (Nominale) : Loan_Status.

## 2- ***Analyse Univariée : Examen de Chaque Variable Individuellement***

### *a. Variables Numériques :*

i. Statistiques descriptives :
"""

# Statistiques descriptives pour les variables numériques (var_num)
print("\nStatistiques descriptives pour les variables numériques (var_num) :")
var_num.describe()

"""- **Comptage (count)** : Pour toutes les variables numériques, le nombre de valeurs est inférieur à 614, ce qui confirme la présence de valeurs manquantes, en particulier pour LoanAmount et Credit_History. ApplicantIncome et CoapplicantIncome ne semblent pas avoir de valeurs manquantes.
- **Moyenne (mean) vs. Médiane (50%)** :
Pour ApplicantIncome, la moyenne (5403) est nettement supérieure à la médiane (3812.5), ce qui suggère une distribution asymétrique à droite (présence de revenus très élevés).
- Une observation similaire peut être faite pour CoapplicantIncome (moyenne de 1621 vs. médiane de 1188.5) et LoanAmount (moyenne de 146.4 vs. médiane de 128).
Pour Loan_Amount_Term, la médiane et le 75ème percentile sont tous deux à 360, ce qui indique que la majorité des prêts ont une durée de remboursement de 360 mois. La moyenne est également proche de 360.
- **Pour Credit_History**, la moyenne de 0.84 indique que la majorité des demandeurs de prêt ont un historique de crédit disponible (codé probablement comme 1).
- **Écart-type (std)** : Des écarts-types élevés pour ApplicantIncome, CoapplicantIncome, et LoanAmount indiquent une grande dispersion des valeurs autour de la moyenne, ce qui renforce l'idée d'une possible asymétrie et présence de valeurs extrêmes. L'écart-type est beaucoup plus faible pour Loan_Amount_Term et Credit_History, suggérant moins de variabilité.
- **Minimum (min) et Maximum (max)** : Les valeurs extrêmes pour ApplicantIncome, CoapplicantIncome, et LoanAmount sont très éloignées des valeurs typiques (moyenne et médiane), ce qui pourrait indiquer la présence de valeurs aberrantes. Par exemple, un revenu de demandeur allant jusqu'à 81000 est significativement plus élevé que la moyenne de 5403. La durée du prêt varie considérablement, de 12 à 480 mois. L'historique de crédit est binaire, avec des valeurs de 0 et 1.
- **Quartiles (25%, 75%)** : Les quartiles nous donnent une idée de la répartition des données. Par exemple, 50% des montants de prêt sont inférieurs ou égaux à 128, et 75% sont inférieurs ou égaux à 168.

#### ii. visualisation
"""

def plot_combined(column):
    fig, axes = plt.subplots(1, 2, figsize=(8, 4))

    # Plot distribution
    sns.histplot(var_num[column], kde=True, ax=axes[0])
    axes[0].set_title(f'Distribution de {column}')
    axes[0].set_xlabel(column)
    axes[0].set_ylabel('Fréquence')

    # Plot boxplot (horizontal)
    sns.boxplot(x=var_num[column], ax=axes[1])
    axes[1].set_title(f'Boîte à moustaches de {column}')
    axes[1].set_xlabel(column)

    plt.tight_layout()
    plt.show()

interactive_combined = interact(plot_combined, column=var_num.columns)

"""OBSERVATIONS

- **ApplicantIncome** : Distribution fortement asymétrique à droite, concentrée sur des revenus plus bas avec une longue queue de revenus élevés. Présence de nombreuses valeurs aberrantes du côté des revenus élevés.
- **CoapplicantIncome** : Distribution très fortement asymétrique à droite, avec un pic important à zéro (beaucoup de demandeurs sans co-emprunteur). Présence de plusieurs valeurs aberrantes élevées pour les revenus des co-emprunteurs.
- **LoanAmount** : Distribution légèrement asymétrique à droite, avec un pic principal autour de montants de prêt moyens (100-150) et une queue de montants plus élevés. Présence de valeurs aberrantes pour les montants de prêt élevés.
- **Loan_Amount_Term** : Variable discrète avec une distribution extrêmement concentrée sur 360 mois. Quelques autres durées (120, 180, 480) sont beaucoup moins fréquentes et apparaissent comme des valeurs éloignées.
- **Credit_History** : Variable binaire catégorielle (0 ou 1), avec une majorité significative de demandeurs ayant un historique de crédit (valeur 1). La valeur 0 représente la minorité sans historique de crédit

INTERPRETATIONS

- **Asymétrie et Valeurs Aberrantes** : Les variables de revenu (ApplicantIncome, CoapplicantIncome) et le montant du prêt (LoanAmount) présentent une asymétrie à droite et des valeurs aberrantes. Cela pourrait influencer les modèles de machine learning sensibles à la distribution des données et aux valeurs extrêmes. Des transformations (logarithmique, par exemple) ou des techniques de traitement des valeurs aberrantes pourraient être envisagées lors de la préparation des données.
- **Concentration de Loan_Amount_Term** : La forte concentration de la durée du prêt sur 360 mois suggère que cette variable pourrait avoir une variance limitée et potentiellement moins d'impact prédictif que d'autres. Il faudra examiner sa relation avec la variable cible.
- **Distribution Binaire de Credit_History** : Le déséquilibre entre les deux catégories de l'historique de crédit (beaucoup plus de '1' que de '0') est important à noter. Cette variable pourrait être un facteur clé dans la décision d'approbation du prêt.
- **Valeurs Manquantes** : Nous avons confirmé la présence de valeurs manquantes dans LoanAmount et Credit_History (déjà notée lors de l'inspection initiale). Les visualisations n'ont pas été faites sur les données imputées, donc le traitement de ces valeurs manquantes sera une étape cruciale avant la modélisation.

### *b. Variables Catégorielles :*
"""

def explore_categorical(column):
    # Tableau de fréquences
    print(f"\nTableau de fréquences pour {column}:")
    print(var_cat[column].value_counts())

    # Tableau de proportions
    print(f"\nTableau de proportions pour {column}:")
    print(var_cat[column].value_counts(normalize=True))

    # Diagramme à barres
    plt.figure(figsize=(6, 4))
    ax = sns.countplot(x=var_cat[column], data=var_cat)
    plt.title(f'Distribution de la variable {column}')
    plt.xlabel(column)
    plt.ylabel('Fréquence')
    plt.xticks(rotation=45, ha='right')

    # Ajouter les étiquettes sur les barres
    for p in ax.patches:
        height = p.get_height()
        ax.text(p.get_x() + p.get_width() / 2., height + 3,
                f'{height}',
                ha='center')

    plt.tight_layout()
    plt.show()

interactive_categorical_exploration = interact(explore_categorical, column=var_cat.columns)

"""Observations :

- **Gender** : L'ensemble de données présente une forte majorité d'hommes - (environ 81.4%) par rapport aux femmes (environ 18.6%).
- **Married** : La majorité des demandeurs de prêt sont mariés (environ 65.1%) par rapport à ceux qui ne le sont pas (environ 34.9%).
- **Dependents** : La majorité des demandeurs n'ont aucun dépendant (environ 57.6%). Le pourcentage diminue avec l'augmentation du nombre de dépendants (1 dépendant : environ 17.0%, 2 dépendants : environ 16.9%, 3+ dépendants : environ 8.5%).
- **Education** : Une large majorité des demandeurs sont diplômés (environ 78.2%) par rapport à ceux qui ne le sont pas (environ 21.8%).
- **Self_Employed** : La grande majorité des demandeurs ne sont pas auto-employés (environ 85.9%) par rapport à ceux qui le sont (environ 14.1%).
- **Property_Area** : La distribution des demandeurs à travers les zones de propriété est relativement équilibrée : Urbaine (environ 32.9%), Rurale (environ 29.2%), et Semi-urbaine (environ 37.9%). La zone semi-urbaine est légèrement plus représentée.
- **Loan_Status** (Variable Cible) : Il y a un déséquilibre significatif dans la variable cible, avec une majorité de prêts approuvés ('Y' : environ 68.7%) par rapport aux prêts refusés ('N' : environ 31.3%).

Conclusions:

- **Déséquilibre de Représentation** : Certaines catégories au sein des variables présentent un déséquilibre de représentation (par exemple, le genre, le statut d'emploi). Cela pourrait influencer l'apprentissage du modèle si ces variables sont corrélées à la variable cible.
- **Importance Potentielle** : Des variables comme le statut matrimonial, le niveau d'éducation et la zone de propriété pourraient potentiellement être des facteurs importants dans la décision d'approbation du prêt.
- **Variable Cible Déséquilibrée** : Le déséquilibre dans Loan_Status est crucial pour les étapes de modélisation et d'évaluation. Il faudra envisager des stratégies pour gérer ce déséquilibre.
- **Distribution de Dependents** : La majorité des demandeurs ayant peu ou pas de dépendants pourrait indiquer que cette caractéristique est prise en compte dans l'évaluation du risque.

### *c. Identification des valeurs manquantes :*
"""

# Compter le nombre de valeurs manquantes par colonne
print("\nNombre de valeurs manquantes par colonne :")
print(Data.isnull().sum())

# Visualisation des valeurs manquantes avec une heatmap
plt.figure(figsize=(8, 4))
sns.heatmap(Data.isnull(), cbar=False, cmap='viridis')
plt.title('Répartition des valeurs manquantes')
plt.show()

"""Certaines colonnes n'ont pas de valeurs manquantes: Loan_ID, Education, ApplicantIncome, CoapplicantIncome, Property_Area, Loan_Status

Voici quelques hypothèses explicatives:

- **Collecte de données incomplète** : Certaines informations n'ont peut-être pas été fournies par les demandeurs lors de la soumission de leur demande.
Erreurs de saisie ou de transmission : Des erreurs lors de l'enregistrement ou du transfert des données pourraient avoir entraîné la perte de certaines valeurs.
- **Non-applicabilité** : Dans certains cas, une question pourrait ne pas être applicable à un demandeur (bien que cela semble moins probable pour les variables que nous observons comme ayant des manquants).
- **Problèmes de système** : Des problèmes techniques lors de la collecte ou du stockage des données pourraient avoir entraîné des pertes.

Sans plus d'informations sur le processus de collecte des données, il est difficile de déterminer la cause exacte des valeurs manquantes. Cependant, la visualisation montre qu'elles sont dispersées, ce qui pourrait suggérer qu'une suppression des lignes avec des valeurs manquantes pourrait entraîner une perte d'informations significative. Par conséquent, des techniques d'imputation (remplacer les valeurs manquantes par des estimations) pourraient être plus appropriées.

### *d. Identification des valeurs abbérantes :*

Méthodes visuelles :

Sur l'analyse précédentes nous avons déjà généré des boîtes à moustaches pour chaque variable numérique. Rappelons nos observations :

- **ApplicantIncome** : Présence de nombreuses valeurs aberrantes élevées.
- **CoapplicantIncome** : Présence de plusieurs valeurs aberrantes élevées.
- **LoanAmount** : Présence de plusieurs valeurs aberrantes élevées.
- **Loan_Amount_Term** : Quelques valeurs éloignées, mais pas nécessairement des aberrations au sens strict d'erreurs de mesure, plutôt des durées de prêt moins fréquentes.

Observations des road causes:

- **Erreurs de saisie** ? Il est possible que certaines valeurs très extrêmes soient des erreurs de saisie (par exemple, un revenu entré avec un zéro supplémentaire). Cependant, sans plus d'informations, il est difficile de le confirmer.
- **Cas exceptionnels **? Il est également possible que ces valeurs représentent des cas réels mais exceptionnels (par exemple, des demandeurs avec des revenus très élevés ou des prêts de montants très importants). Dans ce cas, les supprimer pourrait entraîner une perte d'informations importantes sur la variabilité réelle des données.
- **Influence sur les modèles** ? Les valeurs aberrantes peuvent influencer certains algorithmes de machine learning en biaisant l'apprentissage ou en augmentant la sensibilité aux points individuels.
"""



"""## 3- ***Analyse Bivariée***

### *a. Variables Numériques vs. Numériques :*
"""

# Nuages de points pour visualiser la relation entre paires de variables numériques
sns.pairplot(var_num.dropna()) # Supprimer les NaN pour l'affichage
plt.suptitle("Nuages de points entre variables numériques", y=1.02)
plt.show()

# Matrice de corrélation pour quantifier la relation linéaire
correlation_matrix = var_num.corr()
plt.figure(figsize=(6, 4))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title("Matrice de corrélation entre variables numériques")
plt.show()

"""La matrice de corrélation quantifie les relations linéaires entre les variables numériques :

- **ApplicantIncome et LoanAmount** : La corrélation est de 0.57, ce qui indique une corrélation positive modérée. Cela confirme notre observation du nuage de points selon laquelle les revenus plus élevés sont associés à des montants de prêt légèrement plus importants.
- **CoapplicantIncome et LoanAmount** : La corrélation est de 0.19, indiquant une corrélation positive faible. La relation est moins prononcée qu'avec le revenu du demandeur principal.
- **LoanAmount et Loan_Amount_Term** : La corrélation est de 0.04, ce qui suggère une corrélation très faible, presque inexistante, entre le montant du prêt et sa durée.
- **ApplicantIncome et CoapplicantIncome** : La corrélation est de 0.12, indiquant une corrélation positive faible entre les revenus du demandeur et du co-emprunteur.
- **Credit_History avec ApplicantIncome, CoapplicantIncome, LoanAmount, Loan_Amount_Term** : Les corrélations sont très faibles (proches de zéro), ce qui suggère une absence de relation linéaire forte entre l'historique de crédit (tel que codé numériquement) et ces autres variables numériques.

Conclusions :

- Il existe une corrélation positive modérée entre le revenu du demandeur et le montant du prêt, et une corrélation positive plus faible entre le revenu du co-emprunteur et le montant du prêt.
- La durée du prêt n'est que très faiblement corrélée avec le montant du prêt et les revenus.
- L'historique de crédit (tel que représenté numériquement) ne montre pas de forte corrélation linéaire avec les autres variables numériques. Cependant, il est important de noter que la corrélation de Pearson mesure uniquement les relations linéaires, et une relation non linéaire ou une influence de l'historique de crédit sur les autres variables pourrait exister.

### *b. Variables Numériques vs. **Catégorielles** :*

On va analyser les paires suivantes :
- LoanAmount vs. Loan_Status
- ApplicantIncome vs. Loan_Status
- LoanAmount vs. Gender
- ApplicantIncome vs. Education
- LoanAmount vs. Property_Area
- ApplicantIncome vs. Married
- LoanAmount vs. Self_Employed
- ApplicantIncome vs. Dependents
"""

# Liste des variables numériques (en excluant Loan_ID)
numerical_cols = var_num.columns.tolist()

# Liste des variables catégorielles (en excluant Loan_ID et Loan_Status pour l'instant)
categorical_cols = var_cat.columns.tolist()
if 'Loan_ID' in categorical_cols:
    categorical_cols.remove('Loan_ID')

def plot_num_vs_cat(numerical_col, categorical_col):
    plt.figure(figsize=(8, 5))
    sns.boxplot(x=categorical_col, y=numerical_col, data=Data)
    plt.title(f'Relation entre {numerical_col} et {categorical_col}')
    plt.xlabel(categorical_col)
    plt.ylabel(numerical_col)
    plt.xticks(rotation=45, ha='right')
    plt.tight_layout()
    plt.show()

interactive_num_cat = interact(
    plot_num_vs_cat,
    numerical_col=numerical_cols,
    categorical_col=categorical_cols
)

"""Conclusions de l'Analyse Bivariée (Numérique vs. Catégoriel) :

- **Influence du Statut du Prêt** : Une légère tendance suggère que des montants de prêt légèrement plus élevés pourraient être associés à une approbation, tandis que le revenu du demandeur seul ne semble pas être un facteur discriminant majeur au niveau de la médiane.
- **Impact de l'Éducation et du Statut d'Emploi sur le Revenu et le Montant du Prêt** : Le niveau d'éducation semble avoir une influence notable sur le revenu, les diplômés ayant des revenus médians plus élevés. Le statut d'auto-emploi pourrait être lié à des montants de prêt légèrement plus élevés.
Rôle Modeste du Genre et du Statut Matrimonial : Le genre et le statut matrimonial semblent avoir une influence limitée sur le revenu médian, bien qu'il y ait des différences dans la dispersion et les valeurs aberrantes pour le montant du prêt en fonction du genre.
- **Influence Apparemment Faible de la Zone de Propriété et du Nombre de Dépendants** : La zone de propriété et le nombre de dépendants ne semblent pas avoir d'impact significatif sur le montant du prêt ou le revenu du demandeur au niveau de la médiane.
- **Présence Généralisée de Valeurs Aberrantes** : La présence fréquente de valeurs aberrantes élevées dans les variables de revenu et de montant du prêt, quel que soit le groupe catégoriel, souligne la nécessité d'examiner attentivement leur traitement lors de la préparation des données.

En résumé, cette analyse bivariée commence à révéler des relations potentielles entre les caractéristiques des demandeurs et le montant du prêt ou leur revenu. L'éducation et, dans une moindre mesure, le statut d'emploi et le genre semblent montrer des associations plus claires avec les variables numériques que le statut matrimonial, la zone de propriété ou le nombre de dépendants (du moins au niveau de la médiane). La relation avec la variable cible (Loan_Status) suggère que le montant du prêt pourrait jouer un rôle, mais que d'autres facteurs non encore examinés sont probablement cruciaux pour la décision d'approbation.

### *c. Variables Catégorielles vs. Catégorielles :*

- Maried vs Dependent
- Education vs Self Employed
- Toute autre variable VS Loan Status
"""

# Liste des variables catégorielles (en excluant Loan_ID)
categorical_cols = var_cat.columns.tolist()
if 'Loan_ID' in categorical_cols:
    categorical_cols.remove('Loan_ID')

def explore_categorical_pair(cat_col1, cat_col2):
    # Tableau croisé
    cross_tab = pd.crosstab(Data[cat_col1], Data[cat_col2])
    print(f"\nTableau croisé : {cat_col1} vs. {cat_col2}")
    display(cross_tab)

    # Tableau de proportions (par ligne)
    proportions_row = pd.crosstab(Data[cat_col1], Data[cat_col2], normalize='index')
    print(f"\nProportions (par ligne) : {cat_col1} vs. {cat_col2}")
    display(proportions_row)

    # Diagramme en barres groupées
    cross_tab.plot(kind='bar', stacked=False, figsize=(8, 5))
    plt.title(f'Relation entre {cat_col1} et {cat_col2}')
    plt.xlabel(cat_col1)
    plt.ylabel('Nombre de Demandes')
    plt.xticks(rotation=45, ha='right')
    plt.legend(title=cat_col2)
    plt.tight_layout()
    plt.show()

interactive_cat_cat = interact(
    explore_categorical_pair,
    cat_col1=categorical_cols,
    cat_col2=categorical_cols
)

"""**Rapport d'Analyse : Variables Catégorielles vs. Variables Catégorielles**

- **Gender vs. Loan_Status** : Le taux d'approbation était légèrement plus élevé pour les hommes (environ 69.3%) que pour les femmes (environ 67.0%), mais la différence n'était pas très significative.
- **Married vs. Loan_Status** : Le taux d'approbation était notablement plus élevé pour les personnes mariées (environ 71.6%) que pour les personnes non mariées (environ 62.9%). Le statut matrimonial semble être un facteur plus pertinent pour l'approbation.
- **Dependents vs. Loan_Status** : Le taux d'approbation variait en fonction du nombre de dépendants, avec le taux le plus élevé pour ceux ayant 2 dépendants (environ 75.2%), suivi de ceux sans dépendant (environ 69.1%). Les demandeurs avec 1 ou 3+ dépendants avaient des taux d'approbation plus faibles (environ 64.7%). La relation n'est pas linéaire.
- **Education vs. Loan_Status** : Le taux d'approbation était significativement plus élevé pour les diplômés (environ 70.8%) que pour les non-diplômés (environ 61.2%), suggérant que le niveau d'éducation est un facteur important.
- **Self_Employed vs. Loan_Status** : Les taux d'approbation étaient très similaires pour les non auto-employés (environ 68.6%) et les auto-employés (environ 68.3%), indiquant que le statut d'emploi seul n'est pas un facteur discriminant majeur.
- **Property_Area vs. Loan_Status** : Le taux d'approbation variait considérablement selon la zone de propriété, avec le taux le plus élevé en zone semi-urbaine (environ 76.8%), suivi de la zone urbaine (environ 65.8%), et le taux le plus bas en zone rurale (environ 61.5%). La zone de propriété semble être un facteur important.
- **Married vs. Dependents** : Les personnes non mariées avaient tendance à ne pas avoir de dépendants, tandis que les personnes mariées présentaient une distribution plus diversifiée du nombre de dépendants.
- **Education vs. Self_Employed** : La proportion d'auto-employés était similaire entre les diplômés et les non-diplômés, suggérant une indépendance relative entre ces deux variables.

***Conclusions*** :

**Facteurs d'Approbation Clés** : Le statut matrimonial, le niveau d'éducation et la zone de propriété semblent être des facteurs catégoriels importants associés à la probabilité d'approbation du prêt.

**Influence Non Linéaire des Dépendants**: Le nombre de dépendants montre une relation non monotone avec l'approbation du prêt, avec un taux plus élevé pour 2 dépendants.

**Impact Limité du Genre et du Statut d'Emploi** : Le genre et le statut d'auto-emploi, considérés seuls, ne semblent pas avoir une influence majeure sur le taux d'approbation.

**Relations entre Variables Indépendantes** : Il existe des relations intéressantes entre les variables indépendantes elles-mêmes, comme celle entre le statut matrimonial et le nombre de dépendants.

***Implications pour la Modélisation*** :

Ces observations suggèrent que lors de la construction d'un modèle de prédiction du statut de prêt, les variables Married, Education, Property_Area et Dependents devraient être considérées comme des prédicteurs potentiellement importants. Bien que le genre et le statut d'emploi n'aient pas montré de forte relation directe avec l'approbation, ils pourraient interagir avec d'autres variables et avoir un impact indirect.

L'analyse bivariée des variables catégorielles a révélé des associations significatives qui méritent d'être explorées plus en détail lors de la modélisation.

## 4- ***Analyse Multivariée***
"""

# Liste des variables numériques
numerical_cols = var_num.columns.tolist()

def interactive_colored_pairplot(cols):
    if not cols:
        print("Veuillez sélectionner au moins une variable numérique.")
        return

    # Convertir la tuple en liste si nécessaire
    if isinstance(cols, tuple):
        cols = list(cols)

    cols_for_pairplot = cols + ['Loan_Status']
    data_for_pairplot = Data[cols_for_pairplot].dropna()

    plt.figure(figsize=(12, 10))
    sns.pairplot(data_for_pairplot, hue='Loan_Status', palette={'Y': 'green', 'N': 'red'})
    plt.suptitle(f"Pair Plot coloré par Loan_Status pour les variables : {', '.join(cols)}", y=1.02)
    plt.show()

# Créer une interface de sélection multiple pour les colonnes numériques
numerical_cols_selector = widgets.SelectMultiple(
    options=numerical_cols,
    value=numerical_cols,  # Sélectionner toutes par défaut (vous pouvez changer cela)
    description='Variables Numériques:',
    disabled=False
)

# Afficher l'interface et lier à la fonction de tracé
interact(interactive_colored_pairplot, cols=numerical_cols_selector)

"""Aanalyses :

**Revenues du demandeur VS Montant du prêt VS Prêt**
Cette visualisation renforce l'idée d'une relation positive entre le revenu du demandeur, le montant du prêt et la probabilité d'approbation. Les demandeurs ayant des revenus plus élevés semblent plus susceptibles d'obtenir des prêts plus importants. Cependant, la séparation entre les prêts approuvés et refusés n'est pas nette, soulignant l'importance d'autres variables dans la décision.

**Histirique des prêts VS Montant du prêt VS Prêt**
Les demandeurs ayant un historique de crédit (1) ont une probabilité beaucoup plus élevée d'obtenir l'approbation de leur prêt, et ce, pour une gamme de montants de prêt plus étendue. En revanche, les demandeurs sans historique de crédit (0) sont majoritairement refusés, même pour des montants de prêt plus faibles.

**L'historique de crédit semble être un facteur dominant**. Un historique de crédit présent augmente considérablement la probabilité d'approbation, quel que soit le revenu ou le montant du prêt (bien que des revenus plus élevés puissent faciliter l'approbation de montants plus importants). L'absence d'historique de crédit est un signal fort de refus, même pour des revenus et des montants de prêt apparemment raisonnables.

**Le revenu du demandeur semble jouer un rôle secondaire**, influençant probablement le montant du prêt qui peut être approuvé, surtout en présence d'un historique de crédit favorable.

Conclusion:

Ces visualisations suggèrent que l'historique de crédit, le revenu du demandeur et le montant du prêt sont des facteurs importants et potentiellement interactifs dans la décision d'approbation du prêt. Les modèles prédictifs devront probablement tenir compte de ces relations.

# E - **Préparation des données**

## 1- ***Gestion des valeurs manquantes :***

Méthode d'imputation :
- **Gender**
Imputer avec le mode (la catégorie la plus fréquente). Le genre est une variable catégorielle, et imputer avec la valeur la plus fréquente est une approche simple et courante.

- **Married**
Imputer avec le mode. Similaire à Gender, c'est une variable catégorielle où la valeur la plus fréquente est une imputation raisonnable en l'absence d'autres informations.

- **Dependents**
Imputer avec le mode. Bien qu'il y ait une certaine ordinalité, le mode reste une approche prudente pour cette variable catégorielle.

- **Self_Employed**
Imputer avec le mode. C'est une variable binaire (No/Yes), donc le mode est une imputation simple.

- **LoanAmount**
Imputer avec la médiane. LoanAmount est numérique et présente des valeurs aberrantes. La médiane est moins sensible aux valeurs extrêmes que la moyenne et est donc un choix plus robuste.

- **Loan_Amount_Term**
Imputer avec la médiane. Similaire à LoanAmount, c'est une variable numérique qui pourrait avoir des valeurs extrêmes.

- **Credit_History**
Étant donné l'importance significative de Credit_History que nous avons observée lors de l'EDA, une imputation avec le mode (qui est 1.0, indiquant un historique de crédit présent) pourrait introduire un biais optimiste. Une approche plus prudente serait de :

Analyser plus en détail les raisons des valeurs manquantes si possible (cela dépasse la portée de ce que nous pouvons faire avec les données actuelles).

En l'absence d'informations supplémentaires, imputer avec le mode (1.0), mais créer une variable binaire supplémentaire indiquant si la valeur de Credit_History était manquante à l'origine. Cela permet au modèle de potentiellement apprendre l'impact de l'absence d'information sur l'historique de crédit.
"""

# Imputation du mode pour les variables catégorielles
categorical_missing = ['Gender', 'Married', 'Dependents', 'Self_Employed']
for col in categorical_missing:
    mode_val = Data[col].mode()[0]
    Data[col].fillna(mode_val, inplace=True)

# Imputation de la médiane pour les variables numériques
numerical_missing = ['LoanAmount', 'Loan_Amount_Term']
for col in numerical_missing:
    median_val = Data[col].median()
    Data[col].fillna(median_val, inplace=True)

# Gestion de Credit_History
mode_credit_history = Data['Credit_History'].mode()[0]
Data['Credit_History_Missing'] = Data['Credit_History'].isnull().astype(int)  # Créer une variable indicatrice
Data['Credit_History'].fillna(mode_credit_history, inplace=True)

# Vérifier les valeurs manquantes restantes
print(Data.isnull().sum())

"""## 2- ***Encodage des variables catégorielles :***

Choix d'Encodage :

-** Gender**: One-Hot Encoding (Male, Female)
- **Married**: One-Hot Encoding (Yes, No)
- **Dependents**: Bien qu'il y ait un certain ordre (0, 1, 2, 3+), la distance entre les catégories n'est pas clairement définie. One-Hot Encoding est une approche plus sûre pour éviter d'imposer un ordre potentiellement incorrect.
- **Education**: One-Hot Encoding (Graduate, Not Graduate)
- **Self_Employed**: One-Hot Encoding (Yes, No)
- **Property_Area**: One-Hot Encoding (Rural, Semiurban, Urban)
- **Loan_Status**: Label Encoding (Y=1, N=0) car c'est notre variable cible binaire.
- **Credit_History_Missing**: Déjà numérique (0 ou 1), donc pas besoin d'encodage supplémentaire.
- **Credit_History**: Déjà numérique (0 ou 1), donc pas besoin d'encodage supplémentaire. bold text
"""

print(Data.columns)

# One-Hot Encoding pour les variables spécifiées
categorical_cols_to_encode = ['Gender', 'Married', 'Dependents', 'Education', 'Self_Employed', 'Property_Area']
Data = pd.get_dummies(Data, columns=categorical_cols_to_encode, drop_first=True) # drop_first pour éviter la multicolinéarité

# Label Encoding pour la variable cible Loan_Status
Data['Loan_Status'] = Data['Loan_Status'].map({'Y': 1, 'N': 0})

# Afficher les premières lignes du dataframe encodé et les types de colonnes
Data.head()

"""## 3- ***Gestion des valeurs abbérantes :***

- Compte tenu de la nature asymétrique de ApplicantIncome et LoanAmount que nous avons observée lors de l'EDA, une transformation logarithmique pourrait être une approche judicieuse pour réduire l'impact des valeurs aberrantes élevées et potentiellement rendre la distribution plus normale, ce qui peut être bénéfique pour certains modèles linéaires.

- Pour CoapplicantIncome, la distribution était également asymétrique, mais avec de nombreuses valeurs à zéro. Appliquer une transformation logarithmique directement aux zéros n'est pas possible. Nous pourrions envisager une approche conditionnelle : appliquer le log seulement aux valeurs supérieures à zéro, ou bien utiliser une autre méthode comme la winsorisation. Cependant, étant donné que de nombreux modèles peuvent gérer une certaine asymétrie, et que les valeurs nulles ont une signification (pas de co-demandeur), nous pourrions initialement choisir de ne pas appliquer de transformation à CoapplicantIncome et évaluer son impact lors de la modélisation. Si nécessaire, nous pourrons revenir en arrière et appliquer une autre stratégie.
"""

# Appliquer la transformation logarithmique aux variables sélectionnées
Data['ApplicantIncome_log'] = np.log1p(Data['ApplicantIncome'])
Data['LoanAmount_log'] = np.log1p(Data['LoanAmount'])

# Afficher les distributions après la transformation (facultatif)

plt.figure(figsize=(12, 5))
plt.subplot(1, 2, 1)
sns.histplot(Data['ApplicantIncome_log'])
plt.title('Distribution de ApplicantIncome (log)')

plt.subplot(1, 2, 2)
sns.histplot(Data['LoanAmount_log'])
plt.title('Distribution de LoanAmount (log)')

plt.tight_layout()
plt.show()

# Afficher les premières lignes avec les nouvelles variables
Data.head()

"""On observe que les distributions de ApplicantIncome_log et LoanAmount_log semblent effectivement moins asymétriques et plus proches d'une distribution normale que leurs versions originales. Cela devrait aider nos futurs modèles à mieux apprendre à partir de ces données.

## 4- ***Mise à l'échelle des caractéristiques :***
"""

from sklearn.preprocessing import StandardScaler

# Initialiser le StandardScaler
scaler = StandardScaler()

# Sélectionner les colonnes numériques à standardiser
numerical_cols_to_scale = ['ApplicantIncome_log', 'CoapplicantIncome', 'LoanAmount_log', 'Loan_Amount_Term', 'Credit_History']

# Appliquer la standardisation
Data[numerical_cols_to_scale] = scaler.fit_transform(Data[numerical_cols_to_scale])

# Afficher les premières lignes avec les variables mises à l'échelle
print(Data.head())

"""## 5- ***Sélection des caractéristiques et division des données:***"""

Data.dtypes

# Supprimer Loan_ID du DataFrame Data
Data = Data.drop('Loan_ID', axis=1, errors='ignore')

# Calculer la matrice de corrélation
correlation_matrix = Data.corr()['Loan_Status'].sort_values(ascending=False)
print(correlation_matrix)

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split

# Préparer les données pour le modèle
X = Data.drop('Loan_Status', axis=1, errors='ignore')
y = Data['Loan_Status']

# Diviser les données (si ce n'est pas déjà fait)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Initialiser et entraîner une forêt aléatoire
rf_classifier = RandomForestClassifier(random_state=42)
rf_classifier.fit(X_train, y_train)

# Obtenir l'importance des caractéristiques
feature_importances = pd.Series(rf_classifier.feature_importances_, index=X_train.columns).sort_values(ascending=False)
print("\nImportance des caractéristiques (Forêt Aléatoire):\n", feature_importances)

"""**Décision de Sélection des Caractéristiques :**

Étant donné ces résultats, une approche prudente serait de conserver les caractéristiques qui montrent une corrélation au moins modérée avec la variable cible ou qui sont jugées importantes par le modèle de forêt aléatoire.

**Proposition de caractéristiques à conserver pour commencer :**

- **Credit_History** (forte corrélation et haute importance)
- **ApplicantIncome_log** (importance élevée, faible corrélation directe mais pourrait avoir des interactions)
- **LoanAmount_log** (importance élevée, faible corrélation directe mais pourrait avoir des interactions)
- **CoapplicantIncome** (importance modérée)
- **Property_Area_Semiurban** (corrélation positive modérée, importance modérée)
- **Education_Not Graduate** (corrélation négative modérée, importance faible mais potentiellement utile)
- **Married_Yes** (corrélation positive faible mais cohérente)
- **Credit_History_Missing** (corrélation faible mais pourrait capturer une information importante)

# F - **Sélection du modèle**
"""



"""## 1- ***Régression Logistique :***"""

from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns

# Liste des caractéristiques sélectionnées
selected_features = [
    'Credit_History',
    'ApplicantIncome',
    'LoanAmount',
    'CoapplicantIncome',
    'Property_Area_Semiurban',
    'Loan_Amount_Term',
]

# Créer les ensembles d'entraînement et de test avec les caractéristiques sélectionnées
X_train_selected = X_train[selected_features]
X_test_selected = X_test[selected_features]

# Initialiser et entraîner le modèle de régression logistique
logreg_model = LogisticRegression(random_state=42)
logreg_model.fit(X_train_selected, y_train)

# Faire des prédictions sur l'ensemble de test
y_pred_logreg = logreg_model.predict(X_test_selected)

# Évaluer la performance du modèle
accuracy_logreg = accuracy_score(y_test, y_pred_logreg)
print(f"Précision du modèle de régression logistique sur l'ensemble de test : {accuracy_logreg:.4f}")

print("\nClassification Report (Régression Logistique):\n", classification_report(y_test, y_pred_logreg))

# Afficher la matrice de confusion
cm_logreg = confusion_matrix(y_test, y_pred_logreg)
plt.figure(figsize=(6, 5))
sns.heatmap(cm_logreg, annot=True, fmt='d', cmap='Blues',
            xticklabels=['Refusé (0)', 'Approuvé (1)'],
            yticklabels=['Refusé (0)', 'Approuvé (1)'])
plt.title('Matrice de Confusion (Régression Logistique)')
plt.xlabel('Prédictions')
plt.ylabel('Valeurs Réelles')
plt.show()

"""**Précision (Accuracy)** : Le modèle a une précision de **0.7886**, soit environ **78.9%**. Cela signifie qu'il a correctement classé environ 79% des demandes de prêt dans l'ensemble de test.

**Rapport de Classification** :

1. **Classe 0 (Refusé)** :
- **Précision** : 0.95. Sur toutes les demandes que le modèle a prédit comme étant refusées, 95% l'étaient réellement.

- **Rappel** : 0.42. Sur toutes les demandes réellement refusées, le modèle en a correctement identifié 42%. C'est un score relativement bas, indiquant que le modèle rate une part importante des prêts qui auraient dû être refusés.

- **F1-score** : 0.58. La moyenne harmonique de la précision et du rappel pour la classe 0.

2. **Classe 1 (Approuvé)** :
- **Précision** : 0.76. Sur toutes les demandes que le modèle a prédit comme étant approuvées, 76% l'étaient réellement.
- **Rappel** : 0.99. Sur toutes les demandes réellement approuvées, le modèle en a correctement identifié 99%. C'est un score très élevé, indiquant que le modèle est très bon pour identifier les prêts qui sont approuvés.
- **F1-score** : 0.86. La moyenne harmonique de la précision et du rappel pour la classe 1.

**Matrice de Confusion** :
- Vrais Négatifs : 18. Le modèle a correctement prédit 18 demandes comme étant refusées.
- Faux Positifs : 1. Le modèle a incorrectement prédit 1 demande comme étant approuvée alors qu'elle était refusée.
- Faux Négatifs : 25. Le modèle a incorrectement prédit 25 demandes comme étant refusées alors qu'elles étaient approuvées.
- Vrais Positifs : 79. Le modèle a correctement prédit 79 demandes comme étant approuvées.

**Analyse de la Performance** :

Ce modèle de régression logistique montre une bonne performance globale en termes de précision. Cependant, il y a un déséquilibre notable dans sa capacité à prédire les prêts refusés (classe 0) par rapport aux prêts approuvés (classe 1).

Ce modèle est très performant pour identifier les prêts approuvés (rappel élevé pour la classe 1).

Ce modèle a du mal à identifier tous les prêts qui auraient dû être refusés (rappel faible pour la classe 0). Il y a un nombre relativement élevé de faux négatifs, ce qui signifie que le modèle prédit à tort que de nombreux prêts sont refusés alors qu'ils sont en réalité approuvés.

## 2- ***Forêt Aléatoire (Random Forest) :***
"""

from sklearn.ensemble import RandomForestClassifier

# Initialiser et entraîner le modèle de forêt aléatoire
rf_model = RandomForestClassifier(random_state=42)
rf_model.fit(X_train_selected, y_train)

# Faire des prédictions sur l'ensemble de test
y_pred_rf = rf_model.predict(X_test_selected)

# Évaluer la performance du modèle
accuracy_rf = accuracy_score(y_test, y_pred_rf)
print(f"Précision du modèle de forêt aléatoire sur l'ensemble de test : {accuracy_rf:.4f}")

print("\nClassification Report (Forêt Aléatoire):\n", classification_report(y_test, y_pred_rf))

# Afficher la matrice de confusion
cm_rf = confusion_matrix(y_test, y_pred_rf)
plt.figure(figsize=(6, 5))
sns.heatmap(cm_rf, annot=True, fmt='d', cmap='Greens',
            xticklabels=['Refusé (0)', 'Approuvé (1)'],
            yticklabels=['Refusé (0)', 'Approuvé (1)'])
plt.title('Matrice de Confusion (Forêt Aléatoire)')
plt.xlabel('Prédictions')
plt.ylabel('Valeurs Réelles')
plt.show()

X_train_selected.columns

X_train_selected.dtypes

X_train_selected.head(20)

"""**Comparaison et Analyse :**

**Précision Globale** : La Forêt Aléatoire a une légère amélioration de la précision globale (80.5% vs 78.9%).
- Rappel pour la Classe 0 (Refusé) : La Forêt Aléatoire montre une amélioration notable du rappel pour la classe 0 (0.49 vs 0.42). Cela signifie qu'elle identifie une plus grande proportion des prêts qui auraient dû être refusés.
- Précision pour la Classe 0 (Refusé) : La précision pour la classe 0 est légèrement inférieure pour la Forêt Aléatoire (0.91 vs 0.95), ce qui signifie qu'elle fait un peu plus d'erreurs en prédisant qu'un prêt sera refusé alors qu'il sera approuvé.
- Rappel pour la Classe 1 (Approuvé) : Le rappel pour la classe 1 est légèrement inférieur pour la Forêt Aléatoire (0.97 vs 0.99), ce qui signifie qu'elle rate une plus petite proportion des prêts qui sont réellement approuvés.
- Faux Négatifs (FN) : La Forêt Aléatoire réduit le nombre de faux négatifs (22 vs 25), ce qui est positif car cela signifie qu'elle prédit moins de prêts comme étant refusés alors qu'ils sont approuvés.
- Faux Positifs (FP) : La Forêt Aléatoire augmente légèrement le nombre de faux positifs (2 vs 1), ce qui signifie qu'elle prédit un peu plus de prêts comme étant approuvés alors qu'ils sont refusés.

**Conclusion :**
Le modèle de Forêt Aléatoire semble être une amélioration par rapport à la Régression Logistique, en particulier en termes de rappel pour la classe minoritaire (prêts refusés) et de précision globale. Il fait un meilleur travail d'identification des demandeurs qui seront réellement refusés, tout en maintenant une performance solide pour la prédiction des prêts approuvés.

## 3- ***Gradient Boosting :***
"""

import xgboost as xgb
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
import matplotlib.pyplot as plt
import seaborn as sns


# Initialiser et entraîner le modèle XGBoost
xgb_model = xgb.XGBClassifier(random_state=42)
xgb_model.fit(X_train_selected, y_train)

# Faire des prédictions sur l'ensemble de test
y_pred_xgb = xgb_model.predict(X_test_selected)

# Évaluer la performance du modèle
accuracy_xgb = accuracy_score(y_test, y_pred_xgb)
print(f"Précision du modèle XGBoost sur l'ensemble de test : {accuracy_xgb:.4f}")
print("\nClassification Report (XGBoost):\n", classification_report(y_test, y_pred_xgb))

# Afficher la matrice de confusion
cm_xgb = confusion_matrix(y_test, y_pred_xgb)
plt.figure(figsize=(6, 5))
sns.heatmap(cm_xgb, annot=True, fmt='d', cmap='Purples',
xticklabels=['Refusé (0)', 'Approuvé (1)'],
yticklabels=['Refusé (0)', 'Approuvé (1)'])
plt.title('Matrice de Confusion (XGBoost)')
plt.xlabel('Prédictions')
plt.ylabel('Valeurs Réelles')
plt.show()

"""**Conclusion :**

Pour l'instant, le modèle de Forêt Aléatoire semble offrir la meilleure performance globale, en particulier en améliorant la capacité à identifier les prêts refusés tout en maintenant une bonne performance pour les prêts approuvés.

# G - **Optimisation des hyper paramètres**
"""

from sklearn.model_selection import GridSearchCV
from sklearn.ensemble import RandomForestClassifier

# Définir la grille des hyperparamètres à explorer
param_grid = {
    'n_estimators': [50, 100, 200, 300],
    'max_depth': [None, 10, 20, 30, 40],
    'min_samples_split': [2, 5, 10, 15],
    'min_samples_leaf': [1, 3, 5, 7],
    'max_features': ['sqrt', 'log2']
}

# Initialiser le modèle de forêt aléatoire
rf_model = RandomForestClassifier(random_state=42)

# Initialiser GridSearchCV
grid_search = GridSearchCV(estimator=rf_model,
                           param_grid=param_grid,
                           cv=5,  # Nombre de plis pour la validation croisée
                           scoring='accuracy',  # Métrique à optimiser
                           n_jobs=-1)  # Utiliser tous les cœurs de processeur disponibles

# Lancer la recherche par grille sur les données d'entraînement
grid_search.fit(X_train_selected, y_train)

# Afficher les meilleurs hyperparamètres trouvés
print("Meilleurs hyperparamètres trouvés :", grid_search.best_params_)

# Obtenir le meilleur modèle
best_rf_model = grid_search.best_estimator_

# Évaluer le meilleur modèle sur l'ensemble de test
y_pred_best_rf = best_rf_model.predict(X_test_selected)
accuracy_best_rf = accuracy_score(y_test, y_pred_best_rf)
print(f"\nPrécision du meilleur modèle de forêt aléatoire sur l'ensemble de test : {accuracy_best_rf:.4f}")

print("\nClassification Report (Meilleure Forêt Aléatoire):\n", classification_report(y_test, y_pred_best_rf))

# Afficher la matrice de confusion pour le meilleur modèle
cm_best_rf = confusion_matrix(y_test, y_pred_best_rf)
plt.figure(figsize=(6, 5))
sns.heatmap(cm_best_rf, annot=True, fmt='d', cmap='Oranges',
            xticklabels=['Refusé (0)', 'Approuvé (1)'],
            yticklabels=['Refusé (0)', 'Approuvé (1)'])
plt.title('Matrice de Confusion (Meilleure Forêt Aléatoire)')
plt.xlabel('Prédictions')
plt.ylabel('Valeurs Réelles')
plt.show()

"""- Précision du meilleur modèle de forêt aléatoire sur l'ensemble de test : 0.7886 (environ 78.9%)
- Rapport de Classification (Meilleure Forêt Aléatoire) :

1.   Classe 0 (Refusé) : Précision : 0.95, Rappel : 0.42, F1-score : 0.58
2.   Classe 1 (Approuvé) : Précision : 0.76, Rappel : 0.99, F1-score : 0.86

**Matrice de Confusion (Meilleure Forêt Aléatoire)** :
- Vrais Négatifs (TN) : 18
- Faux Positifs (FP) : 1
- Faux Négatifs (FN) : 25
- Vrais Positifs (TP) : 79

**Analyse** :

L'optimisation des hyperparamètres, dans ce cas, n'a pas amélioré la performance du modèle de Forêt Aléatoire sur l'ensemble de test. En fait, la précision globale a légèrement diminué (de 0.8049 à 0.7886). De plus, le rappel pour la classe 0 (prêts refusés) a diminué (de 0.49 à 0.42), tandis que le rappel pour la classe 1 (prêts approuvés) a légèrement augmenté (de 0.97 à 0.99).

Cela suggère que les hyperparamètres par défaut de la Forêt Aléatoire étaient en fait assez performants pour cet ensemble de données et cette sélection de caractéristiques. L'optimisation a peut-être conduit à un modèle légèrement plus biaisé vers la prédiction de la classe majoritaire (prêts approuvés).
"""

import warnings
warnings.filterwarnings("ignore", category=UserWarning) # Pour ignorer les UserWarning spécifiques à LightGBM

# ... votre code d'entraînement LightGBM ...

warnings.filterwarnings("default", category=UserWarning) # Pour rétablir l'affichage des avertissements par défaut

import lightgbm as lgb
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# Initialiser et entraîner le modèle LightGBM
lgbm_model = lgb.LGBMClassifier(random_state=42)
lgbm_model.fit(X_train_selected, y_train)

# Faire des prédictions sur l'ensemble de test
y_pred_lgbm = lgbm_model.predict(X_test_selected)

# Évaluer la performance du modèle
accuracy_lgbm = accuracy_score(y_test, y_pred_lgbm)
print(f"Précision du modèle LightGBM sur l'ensemble de test : {accuracy_lgbm:.4f}")

print("\nClassification Report (LightGBM):\n", classification_report(y_test, y_pred_lgbm))

# Afficher la matrice de confusion
cm_lgbm = confusion_matrix(y_test, y_pred_lgbm)
plt.figure(figsize=(6, 5))
sns.heatmap(cm_lgbm, annot=True, fmt='d', cmap='YlGnBu',
            xticklabels=['Refusé (0)', 'Approuvé (1)'],
            yticklabels=['Refusé (0)', 'Approuvé (1)'])
plt.title('Matrice de Confusion (LightGBM)')
plt.xlabel('Prédictions')
plt.ylabel('Valeurs Réelles')
plt.show()

"""CHOIX DU MEILLEUR MODELE :

![image.png](data:image/png;base64,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)

**Analyse Comparative :**

**Précision Globale** : La Forêt Aléatoire (par défaut) a obtenu la meilleure précision globale (80.5%), indiquant qu'elle a fait le plus grand nombre de prédictions correctes sur l'ensemble des données de test.

**Performance sur la Classe "Refusé" (Classe 0)** :

- Rappel : LightGBM a le meilleur rappel (51%), suivi de près par la Forêt Aléatoire et XGBoost (49%). La Régression Logistique et la Forêt Aléatoire optimisée ont un rappel plus faible (42%). Un rappel plus élevé est crucial si nous voulons minimiser le risque de refuser des prêts qui auraient dû être approuvés.
- F1-score : La Forêt Aléatoire (par défaut) a le meilleur F1-score (0.64) pour la classe "Refusé", suggérant un meilleur équilibre entre la précision et le rappel pour cette classe. LightGBM suit avec un F1-score de 0.61.


**Performance sur la Classe "Approuvé" (Classe 1) :**

- Rappel : La Régression Logistique et la Forêt Aléatoire (optimisée) ont le meilleur rappel (99%), suivies de près par la Forêt Aléatoire (par défaut) à 97%. XGBoost et LightGBM ont un rappel légèrement inférieur (90% et 91% respectivement). Un rappel élevé est important pour identifier la majorité des prêts qui seront approuvés.
- F1-score : La Forêt Aléatoire (par défaut) a le meilleur F1-score (0.87) pour la classe "Approuvé". La Régression Logistique et la Forêt Aléatoire optimisée suivent avec un F1-score de 0.86.

**Arguments pour le Choix du Meilleur Modèle** :

***Le choix du "meilleur" modèle dépendra des priorités et des objectifs métier*** :
- Si l'objectif principal est la précision globale : La Forêt Aléatoire (par défaut) est le meilleur choix avec la précision la plus élevée (80.5%).

- Si la minimisation des faux négatifs (refuser des prêts qui auraient dû être approuvés) est une priorité : LightGBM a le meilleur rappel pour la classe "Refusé" (51%), ce qui signifie qu'il est le plus performant pour identifier les demandes qui auraient dû être approuvées. Cependant, sa précision globale est légèrement inférieure.

- Si un bon équilibre entre la précision et le rappel pour la classe "Refusé" est important : La Forêt Aléatoire (par défaut) offre le meilleur F1-score (0.64) pour cette classe, indiquant un bon compromis.

- La Régression Logistique et la Forêt Aléatoire optimisée excellent dans l'identification des prêts approuvés (rappel élevé pour la classe 1) mais sont moins performantes pour identifier les prêts refusés.

**Recommandation Initiale** :

Compte tenu de la meilleure précision globale et du bon équilibre entre la précision et le le rappel pour les deux classes (indiqué par les F1-scores), la Forêt Aléatoire (par défaut) semble être un candidat solide comme modèle initial.

Cependant, si la priorité est de minimiser les faux négatifs (éviter de refuser des prêts potentiellement bons), LightGBM pourrait être envisagé en raison de son meilleur rappel pour la classe "Refusé".

#  **SAUVEGARDE DU MODELE :**
"""

pkl.dump(rf_model, open('model.pkl', 'wb'))

"""#  **Installation de Streamlit et streamlit-jupyter :**"""





"""#  **APPLICATION :**"""

